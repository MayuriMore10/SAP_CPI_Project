<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JMS Queues - SAP CPI Dashboard</title>
    <link rel="stylesheet" href="/static/styles.css" />
</head>
<body class="light">
    <div class="layout">
        <aside class="sidebar">
            <div class="brand">Dashboard</div>
            <nav>
                <a href="/login">Login</a>
                <a href="/">Home</a>
                <a href="/show">Message Stores</a>
            </nav>
        </aside>
        <main class="content">
            <div class="container">
                <h1>JMS Queues</h1>
                <div class="card">
                    <h2>Overview</h2>
                    <p>JMS (Java Message Service) Queues in SAP Integration Suite provide asynchronous messaging capabilities. They enable reliable message delivery and decoupling between different parts of your integration landscape.</p>
                </div>
                <div class="actions">
                    <button id="btnLoadQueues">Load JMS Queues</button>
                    <button id="btnClear" class="ghost">Clear</button>
                </div>
                <div id="tableWrap" class="table-wrap"></div>
            </div>
        </main>
    </div>

    <script>
    const tableWrap = document.getElementById('tableWrap');
    function renderTable(items){
        if (!Array.isArray(items)) items = [];
        if (items.length === 0){ 
            tableWrap.innerHTML = `
                <div class="card">
                    <h3>No JMS Queues Found</h3>
                    <p>This could be because:</p>
                    <ul>
                        <li>No JMS queues are configured in your CPI tenant</li>
                        <li>No integration flows with JMS adapters are deployed</li>
                        <li>The JMS queue API endpoint is not available</li>
                        <li>Insufficient permissions to access JMS queue information</li>
                    </ul>
                    <p><strong>Note:</strong> JMS queues are automatically created when you deploy integration flows that use JMS adapters.</p>
                </div>
            `; 
            return; 
        }
        const columns = Object.keys(items[0]);
        let html = '<table class="table"><thead><tr>' + columns.map(c=>`<th>${c}</th>`).join('') + '</tr></thead><tbody>';
        for (const row of items){
            html += '<tr>' + columns.map(c=>`<td>${escapeHtml(row[c])}</td>`).join('') + '</tr>';
        }
        html += '</tbody></table>';
        tableWrap.innerHTML = html;
    }
    function escapeHtml(v){
        if (v == null) return '';
        return String(v).replace(/[&<>"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]));
    }
    async function fetchAndRender(path){
        try {
            console.log('Fetching from:', path);
            const res = await fetch(path);
            console.log('Response status:', res.status);
            const data = await res.json();
            console.log('Raw response data:', data);
            
            // Handle error responses
            if (data.error) {
                tableWrap.innerHTML = `
                    <div class="card">
                        <h3>API Error</h3>
                        <p><strong>Error:</strong> ${data.error}</p>
                        ${data.tried_endpoints ? `<p><strong>Tried endpoints:</strong> ${data.tried_endpoints.join(', ')}</p>` : ''}
                    </div>
                `;
                return;
            }
            
            const items = normalize(data);
            console.log('Normalized items:', items);
            renderTable(items);
        } catch (err) {
            console.error('Fetch error:', err);
            tableWrap.innerHTML = `
                <div class="card">
                    <h3>Connection Error</h3>
                    <p><strong>Error:</strong> ${err.message}</p>
                    <p>Please check your internet connection and try again.</p>
                </div>
            `;
        }
    }
    function normalize(resp){
        console.log('Normalizing response:', resp);
        if (!resp || !resp.data) return [];
        const data = resp.data;
        if (data.d && Array.isArray(data.d.results)){
            return data.d.results.map(pick);
        }
        if (data.d && typeof data.d === 'object'){
            return [pick(data.d)];
        }
        return [];
    }
    function pick(obj){
        console.log('Available fields in Queue:', Object.keys(obj));
        const out = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                // Format date fields
                if (key.includes('Date') || key.includes('At') || key.includes('Time')) {
                    out[key] = formatDate(obj[key]);
                } else {
                    out[key] = obj[key];
                }
            }
        }
        return out;
    }
    
    function formatDate(dateString) {
        if (!dateString) return '';
        try {
            // Handle different date formats
            let date;
            if (dateString.includes('T')) {
                // ISO format: 2023-12-25T10:30:00Z
                date = new Date(dateString);
            } else if (dateString.includes('/')) {
                // Already formatted
                return dateString;
            } else {
                // Try parsing as timestamp or other format
                date = new Date(dateString);
            }
            
            if (isNaN(date.getTime())) return dateString;
            
            // Format as DD/MM/YYYY HH:MM:SS
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            
            return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
        } catch (e) {
            return dateString;
        }
    }
    document.getElementById('btnLoadQueues').addEventListener('click', ()=> fetchAndRender('/api/queues/jms'));
    document.getElementById('btnClear').addEventListener('click', ()=> { tableWrap.innerHTML = ''; });
    </script>
</body>
</html>
